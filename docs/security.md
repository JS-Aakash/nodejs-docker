# Security Design & Threat Model
**Hybrid AWS RAG System**

## 1. Threat Model & Attack Surface

### **Assets**
- **User Documents**: Confidential PDFs stored in S3.
- **Knowledge Base**: Vector embeddings derived from documents.
- **Infrastructure**: AWS Lambda (Ingest/Proxy) and EC2 (AI Worker).
- **Secrets**: API Keys (Groq/OpenAI), AWS Credentials.

### **Attack Vectors & Mitigations**
| Threat | Mitigation Strategy |
| :--- | :--- |
| **Unauthorized Uploads** | All uploads require a pre-signed URL generated by an authenticated Lambda. No public S3 write access. |
| **Data Exfiltration (S3)** | S3 Bucket is private. Only specific IAM roles can read. No public read access. |
| **Data Exfiltration (EC2)** | EC2 runs in a private subnet (recommended) or locked down via Security Groups to allow inbound only on port 3000 from specific sources. |
| **Prompt Injection** | LLM System Prompt instructs the model to valid *only* based on provided context. Inputs are sanitized. |
| **Privilege Escalation** | IAM Roles follow strict **Least Privilege**. No `*` permissions on resources. No admin access. |
| **Container Breakout** | Docker container runs as a non-root user (`appuser`). |

---

## 2. Identity & Access Management (IAM)

### **A. Lambda Execution Role**
The serverless layer acts as the orchestrator. It needs privileges to write logs and manage S3 objects within the specific project bucket.

**Policy Snippet (Serverless Framework):**
```yaml
- Effect: Allow
  Action:
    - logs:CreateLogGroup
    - logs:CreateLogStream
    - logs:PutLogEvents
  Resource: "arn:aws:logs:*:*:*"
- Effect: Allow
  Action:
    - s3:PutObject
    - s3:GetObject
  Resource: "arn:aws:s3:::my-project-bucket/*"
```
*Rationale*: `PutObject` allows generating pre-signed URLs. `GetObject` is technically not needed by the Lambda itself if the EC2 worker does the reading, but is included if Lambda needs to validate file existence.

### **B. EC2 Worker Instance Profile**
The EC2 instance performs the heavy lifting. It needs to pull images from ECR and read PDFs from S3.

**Required Permissions:**
- **AmazonEC2ContainerRegistryReadOnly**: To pull the Docker image.
  - `ecr:GetAuthorizationToken`
  - `ecr:BatchGetImage`
  - `ecr:GetDownloadUrlForLayer`
- **S3 Read Access**: To download PDFs for processing.
  - `s3:GetObject` on `arn:aws:s3:::my-project-bucket/*`
- **SSM Managed Instance Core**: To allow deployment without SSH.
  - `ssm:UpdateInstanceInformation`
  - `ssmmessages:CreateControlChannel`
  - `ssmmessages:CreateDataChannel`
- **CloudWatch Logs**: For application logging.
  - `logs:CreateLogStream`
  - `logs:PutLogEvents`

---

## 3. Network Security

### **Trust Boundaries**
1.  **Public Internet -> API Gateway**: The only public entry point. Protected by throttling and validation.
2.  **API Gateway -> Lambda**: Internal AWS invocation. Secure by design.
3.  **Lambda -> EC2 Worker**: Traffic flows over the internal network (if VPC peered) or public internet via HTTP.
    *   **Action**: EC2 Security Group should allow Inbound Port 3000 from **Anywhere (0.0.0.0/0)** if relying on public IP, OR strictly from the **Lambda's Elastic IP / NAT Gateway IP** if configured.
    *   *Ideal State*: Lambda in VPC -> Private Link/NAT -> EC2 in Private Subnet.
4.  **EC2 -> S3 / ECR / LLM APIs**: Outbound traffic allowed (HTTPS port 443).

### **EC2 Security Group Rules**
| Type | Protocol | Port | Source | Description |
| :--- | :--- | :--- | :--- | :--- |
| Inbound | TCP | 3000 | 0.0.0.0/0 (or restricted IP) | API Access from Lambda Proxy |
| Outbound | TCP | 443 | 0.0.0.0/0 | Access to AWS APIs (S3, ECR) & LLM Providers |
| Inbound | TCP | 22 | **DENY** | SSH is disabled. Use SSM Session Manager. |

---

## 4. Secrets Management

*   **At Rest**: Secrets (API Keys) are stored in **GitHub Secrets** (for CI/CD) and effectively **AWS Parameter Store / Secrets Manager** (if implemented for production).
*   **In Transit**: Injected into the runtime environment:
    *   **Lambda**: Environment variables configured in `serverless.yml`.
    *   **EC2**: Passed securely via the `docker run` command string executed by SSM Agent.
*   **Logs**: Application code explicitly avoids logging sensitive environment variables.

## 5. Failure & Timeout Handling

*   **Lambda Timeouts**:
    *   API Gateway hard limit: 30s.
    *   Lambda configured timeout: 30s.
    *   Proxy Logic: Implements a 25s internal abort signal to return a clean `504 Gateway Timeout` JSON response before the AWS infrastructure hard-kills the process.
*   **EC2 Failures**:
    *   Docker restart policy: `unless-stopped`. If the app crashes, it auto-restarts.
    *   Deployment: Uses rolling updates (Standard `docker stop` -> `docker run`).

---

**Generated by AI Architect for Enterprise Verification**
